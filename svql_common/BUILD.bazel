load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
load("@bazel_skylib//rules:run_binary.bzl", "run_binary")

run_binary(
    name = "header",
    srcs = glob(["src/**/*.rs"]),
    outs = ["include/source.h"],
    args = ["--crate", "svql_common", "--lang", "C", "--include-guard", "SVQL_COMMON_SOURCE_H", "--output", "include/source.h"],
    tool = "cbindgen",
    visibility = ["//visibility:public"],
)

# ---------------------------------------------------------------------------
# Step (b) – the actual Rust code, compiled as a static library suitable
# for *native* (C/C++) linking.
# ---------------------------------------------------------------------------
rust_library(
    name = "svql_common",
    crate_root = "src/lib.rs",
    srcs = glob(["src/**/*.rs"]),
    edition = "2024",
    deps = [
        "@crates//:lazy_static",
        "@crates//:regex",
    ],
    crate_features = [],
    visibility = ["//visibility:public"],
)

# ---------------------------------------------------------------------------
# Step (c) – a cc_library wrapper that re-exports the generated header.  This
# is what downstream C / C++ code depends on.
# ---------------------------------------------------------------------------

cc_library(
    name = "ffi",
    hdrs = [":svql_common_header"],
    deps  = [":svql_common"],
    visibility = ["//visibility:public"],
)