// svql_subgraph/build.rs
// Generates a test per TestCase that runs the subgraph matcher for netlist-backed test cases.

use std::{
    env,
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

use regex::Regex;

fn main() {
    // Re-run whenever the list of test cases changes
    println!("cargo:rerun-if-changed=../svql_common/src/test_cases.rs");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let common_dir = manifest_dir.join("..").join("svql_common");
    let test_cases_rs = common_dir.join("src").join("test_cases.rs");

    let test_case_names = extract_test_case_names(&test_cases_rs);

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let out_file = out_dir.join("svql_subgraph_generated_tests.rs");
    let mut f = File::create(&out_file).expect("Failed to create generated tests file");

    // Header
    writeln!(
        f,
        r#"
// Auto-generated by build.rs. Do not edit by hand.

use svql_common::{{ALL_TEST_CASES, Pattern, import_design}};
"#
    )
    .unwrap();

    // Generate a #[test] per TestCase name
    for name in &test_case_names {
        let fn_name = sanitize_ident(&format!("test_subgraph_{}", name));
        let name_lit = escape_rust_string(name);

        writeln!(
            f,
            r#"
#[test]
fn {fn_name}() {{
    // Initialize test logger (captured by the test harness)
    let _ = env_logger::builder().is_test(true).try_init();

    // Find the TestCase by name
    let tc = ALL_TEST_CASES
        .iter()
        .find(|t| t.name == "{name_lit}")
        .expect("TestCase not found by name");

    // Only run for netlist-backed test cases
    if let Pattern::Netlist {{ path, module, .. }} = tc.pattern {{
        let needle = import_design(path.into(), module)
            .unwrap_or_else(|e| panic!("Failed to load needle {{}}: {{}}", path, e));
        let haystack = import_design(tc.haystack.path.into(), tc.haystack.module)
            .unwrap_or_else(|e| panic!("Failed to load haystack {{}}: {{}}", tc.haystack.path, e));

        let matches = svql_subgraph::find_subgraphs(&needle, &haystack, &tc.config);
        assert_eq!(
            matches.len(),
            tc.expected_matches,
            "Subgraph test case '{{}}' failed: expected {{}} matches, got {{}}",
            tc.name,
            tc.expected_matches,
            matches.len()
        );
    }} else {{
        // Not applicable for subgraph engine; no-op to mirror previous selective test behavior
    }}
}}
"#,
            fn_name = fn_name,
            name_lit = name_lit
        )
        .unwrap();
    }
}

fn extract_test_case_names(path: &Path) -> Vec<String> {
    let Ok(content) = fs::read_to_string(path) else {
        return Vec::new();
    };
    // Match: TestCase { name: "..." , ... }
    let re = Regex::new(r#"TestCase\s*\{\s*name:\s*"([^"]+)""#).unwrap();
    re.captures_iter(&content)
        .filter_map(|c| c.get(1).map(|m| m.as_str().to_string()))
        .collect()
}

fn sanitize_ident(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for (i, ch) in s.chars().enumerate() {
        let valid = ch.is_ascii_alphanumeric() || ch == '_';
        if (i == 0 && ch.is_ascii_digit()) || !valid {
            out.push('_');
        } else {
            out.push(ch);
        }
    }
    out
}

fn escape_rust_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}
