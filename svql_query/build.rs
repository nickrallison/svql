// svql_query/build.rs
// Scans src/queries for known query types and generates a static registry
// of typed runners to be used by integration tests.

use std::{
    env,
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

use regex::Regex;
use walkdir::WalkDir;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum QueryKind {
    Netlist,
    Composite,
    EnumComposite,
}

#[derive(Debug, Clone)]
struct Discovered {
    kind: QueryKind,
    type_name: String,
    module_path: String, // like: crate::queries::netlist::basic::and
}

fn main() {
    println!("cargo:rerun-if-chended=src/queries");
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let src_queries = manifest_dir.join("src").join("queries");

    let mut found: Vec<Discovered> = Vec::new();

    // Regexes to capture types
    // Capture `name: TypeName` inside netlist! { ... }
    let re_netlist = Regex::new(r#"netlist!\s*\{\s*name:\s*([A-Za-z_][A-Za-z0-9_]*)"#).unwrap();

    // Capture `impl SearchableComposite for TypeName<Search>`
    let re_composite = Regex::new(
        r#"impl\s+SearchableComposite\s+for\s+([A-Za-z_][A-Za-z0-9_]*)\s*<\s*Search\s*>"#,
    )
    .unwrap();

    // Capture `impl SearchableEnumComposite for TypeName<Search>`
    let re_enum_composite = Regex::new(
        r#"impl\s+SearchableEnumComposite\s+for\s+([A-Za-z_][A-Za-z0-9_]*)\s*<\s*Search\s*>"#,
    )
    .unwrap();

    for entry in WalkDir::new(&src_queries)
        .into_iter()
        .filter_map(Result::ok)
    {
        let path = entry.path();
        if !path.is_file() || path.extension().and_then(|s| s.to_str()) != Some("rs") {
            continue;
        }
        let content = match fs::read_to_string(path) {
            Ok(s) => s,
            Err(_) => continue,
        };

        let module_path = path_to_module_path(&src_queries, path);

        // netlist
        for cap in re_netlist.captures_iter(&content) {
            let type_name = cap[1].to_string();
            found.push(Discovered {
                kind: QueryKind::Netlist,
                type_name: type_name.clone(),
                module_path: module_path.clone(),
            });
        }

        // composite
        for cap in re_composite.captures_iter(&content) {
            let type_name = cap[1].to_string();
            found.push(Discovered {
                kind: QueryKind::Composite,
                type_name: type_name.clone(),
                module_path: module_path.clone(),
            });
        }

        // enum composite
        for cap in re_enum_composite.captures_iter(&content) {
            let type_name = cap[1].to_string();
            found.push(Discovered {
                kind: QueryKind::EnumComposite,
                type_name: type_name.clone(),
                module_path: module_path.clone(),
            });
        }
    }

    // Dedup by (kind, type_name, module_path)
    found.sort_by(|a, b| {
        (format!("{:?}", a.kind), &a.type_name, &a.module_path).cmp(&(
            format!("{:?}", b.kind),
            &b.type_name,
            &b.module_path,
        ))
    });
    found.dedup_by(|a, b| {
        a.kind == b.kind && a.type_name == b.type_name && a.module_path == b.module_path
    });

    // Generate registry source
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_file = out_dir.join("svql_query_registry.rs");
    let mut f = File::create(&out_file).expect("Failed to create generated registry file");

    // Header
    writeln!(
        f,
        "{}",
        r#"
// Auto-generated by build.rs. Do not edit by hand.
use svql_query::netlist::SearchableNetlist;
use svql_query::composite::{SearchableComposite, SearchableEnumComposite};


pub struct Entry {
    pub name: &'static str,
    pub run_count: fn(&svql_driver::Driver, &svql_common::TestCase) -> Result<usize, String>,
}

fn pascal_to_snake(s: &str) -> String {
    // Very small, local snake_case converter for registry aliasing
    // Example: "SdffeThenAnd" -> "sdffe_then_and"
    let mut out = String::with_capacity(s.len() * 2);
    for (i, ch) in s.chars().enumerate() {
        if ch.is_ascii_uppercase() {
            if i != 0 {
                out.push('_');
            }
            out.push(ch.to_ascii_lowercase());
        } else {
            out.push(ch);
        }
    }
    out
}
"#
    )
    .unwrap();

    // Per-type runners and entries
    let mut entries: Vec<String> = Vec::new();

    for d in &found {
        let full_path = format!("{}::{}", d.module_path, d.type_name);
        let type_name = &d.type_name;
        let runner_fn = format!("run_count_for_{}", type_name);

        writeln!(
            f,
            r#"
#[allow(non_snake_case)]
fn {runner}(driver: &svql_driver::Driver, tc: &svql_common::TestCase) -> Result<usize, String> {{
    // Use the type: {full}
    let ctx = {full}::<svql_query::Search>::context(driver).map_err(|e| e.to_string())?;
    let (hk, hd) = driver
        .get_or_load_design(tc.haystack.path, tc.haystack.module.to_string())
        .map_err(|e| e.to_string())?;
    let ctx = ctx.with_design(hk.clone(), hd);
    let root = svql_query::instance::Instance::root(tc.name.to_string());
    let hits = {full}::<svql_query::Search>::query(&hk, &ctx, root, &tc.config);
    Ok(hits.len())
}}
"#,
            runner = runner_fn,
            full = full_path
        )
        .unwrap();

        // Add two entries: PascalCase and snake_case aliases
        let entry_pascal = format!(
            r#"Entry {{ name: "{}", run_count: {} }},"#,
            type_name, runner_fn
        );
        let entry_snake = format!(
            r#"Entry {{ name: "{}", run_count: {} }},"#,
            pascal_to_snake(type_name),
            runner_fn
        );
        entries.push(entry_pascal);
        entries.push(entry_snake);
    }

    // Emit registry and accessor functions
    writeln!(
        f,
        "static REGISTRY: &[Entry] = &[\n    {}\n];",
        entries.join("\n    ")
    )
    .unwrap();

    writeln!(
        f,
        r#"
pub fn run_count_by_name(name: &str, driver: &svql_driver::Driver, tc: &svql_common::TestCase) -> Option<Result<usize, String>> {{
    for e in REGISTRY {{
        if e.name == name {{
            return Some((e.run_count)(driver, tc));
        }}
    }}
    None
}}

pub fn available_names() -> &'static [&'static str] {{
    // Return just the names to aid debugging
    const NAMES: &[&str] = &[
        {}
    ];
    NAMES
}}
"#,
        found
            .iter()
            .flat_map(|d| {
                let pascal = &d.type_name;
                let snake = pascal_to_snake(pascal);
                vec![format!(r#""{}""#, pascal), format!(r#""{}""#, snake)]
            })
            .collect::<Vec<_>>()
            .join(", ")
    )
    .unwrap();

    println!(
        "cargo:warning=svql_query: generated registry for {} query type(s)",
        found.len()
    );
}

fn path_to_module_path(base: &Path, file: &Path) -> String {
    // Convert src/queries/netlist/basic/and.rs -> svql_query::queries::netlist::basic::and
    let _rel = file.strip_prefix(base).unwrap_or(file);
    let mut comps: Vec<String> = Vec::new();
    comps.push("svql_query".to_string());
    comps.push("queries".to_string());

    let under_queries = file.strip_prefix(base).unwrap_or(file);
    for c in under_queries
        .parent()
        .into_iter()
        .flat_map(|p| p.components())
    {
        let s = c.as_os_str().to_string_lossy().to_string();
        comps.push(s);
    }

    // final segment: file stem
    if let Some(stem) = file.file_stem().and_then(|s| s.to_str()) {
        comps.push(stem.to_string());
    }
    comps.join("::")
}

fn pascal_to_snake(s: &str) -> String {
    let mut out = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_ascii_uppercase() {
            if i != 0 {
                out.push('_');
            }
            out.push(ch.to_ascii_lowercase());
        } else {
            out.push(ch);
        }
    }
    out
}
