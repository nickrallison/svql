// svql_query/build.rs
// Generates a test per TestCase and a shared matcher that dispatches by
// fully-qualified query type (directly embedding the path into the generated code).

use std::{
    env,
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

use regex::Regex;
use walkdir::WalkDir;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum QueryKind {
    Netlist,
    Composite,
    EnumComposite,
}

#[derive(Debug, Clone)]
struct Discovered {
    kind: QueryKind,
    type_name: String,   // e.g., "AndGate"
    module_path: String, // e.g., "svql_query::queries::netlist::basic::and"
}

fn main() {
    // Re-run if these change
    println!("cargo:rerun-if-changed=src/queries");
    println!("cargo:rerun-if-changed=../svql_common/src/test_cases.rs");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let src_queries = manifest_dir.join("src").join("queries");

    let mut found: Vec<Discovered> = discover_query_types(&src_queries);

    // Dedup by (kind, type_name, module_path)
    found.sort_by(|a, b| {
        (format!("{:?}", a.kind), &a.type_name, &a.module_path).cmp(&(
            format!("{:?}", b.kind),
            &b.type_name,
            &b.module_path,
        ))
    });
    found.dedup_by(|a, b| {
        a.kind == b.kind && a.type_name == b.type_name && a.module_path == b.module_path
    });

    // Extract test case names from svql_common/src/test_cases.rs
    let common_dir = manifest_dir.join("..").join("svql_common");
    let test_cases_rs = common_dir.join("src").join("test_cases.rs");
    let test_case_names = extract_test_case_names(&test_cases_rs);

    // Generate tests source
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_file = out_dir.join("svql_query_generated_tests.rs");
    let mut f = File::create(&out_file).expect("Failed to create generated tests file");

    // Header with a shared runner that dispatches by fully qualified type
    writeln!(
        f,
        r#"
// Auto-generated by build.rs. Do not edit by hand.

use svql_common::{{ALL_TEST_CASES, Pattern}};
use svql_driver::Driver;
use svql_query::Search;
use svql_query::composite::{{SearchableComposite, SearchableEnumComposite}};
use svql_query::netlist::SearchableNetlist;

// Return Ok(count) if name is known, otherwise Err("Unknown query type: ...")
fn run_count_by_type_name(
    name: &str,
    driver: &Driver,
    tc: &svql_common::TestCase,
) -> Result<usize, String> {{
    // Big match of fully-qualified type names discovered under src/queries
    match name {{
"#
    )
    .unwrap();

    // Emit match arms for all discovered types, embedding the type path directly.
    for d in &found {
        let full_path = format!("{}::{}", d.module_path, d.type_name);

        // Legacy alias for composites to match your existing TestCase paths:
        // "svql_query::queries::netlist::composite::<TypeName>"
        let legacy = match d.kind {
            QueryKind::Composite | QueryKind::EnumComposite => {
                format!("svql_query::queries::netlist::composite::{}", d.type_name)
            }
            _ => String::new(),
        };

        if legacy.is_empty() {
            writeln!(
                f,
                r#"
        "{full}" => {{
            let ctx = {full}::<Search>::context(driver).map_err(|e| e.to_string())?;
            let (hk, hd) = driver
                .get_or_load_design(tc.haystack.path, tc.haystack.module.to_string())
                .map_err(|e| e.to_string())?;
            let ctx = ctx.with_design(hk.clone(), hd);
            let root = svql_query::instance::Instance::root(tc.name.to_string());
            let hits = {full}::<Search>::query(&hk, &ctx, root, &tc.config);
            Ok(hits.len())
        }},"#,
                full = full_path
            )
            .unwrap();
        } else {
            writeln!(
                f,
                r#"
        "{full}" | "{legacy}" => {{
            let ctx = {full}::<Search>::context(driver).map_err(|e| e.to_string())?;
            let (hk, hd) = driver
                .get_or_load_design(tc.haystack.path, tc.haystack.module.to_string())
                .map_err(|e| e.to_string())?;
            let ctx = ctx.with_design(hk.clone(), hd);
            let root = svql_query::instance::Instance::root(tc.name.to_string());
            let hits = {full}::<Search>::query(&hk, &ctx, root, &tc.config);
            Ok(hits.len())
        }},"#,
                full = full_path,
                legacy = legacy
            )
            .unwrap();
        }
    }

    // Close the match and function (escape {{}} for the outer writeln! format)
    writeln!(
        f,
        r#"
        _ => Err(format!("Unknown query type: {{}}", name)),
    }}
}}
"#
    )
    .unwrap();

    // Generate a #[test] per TestCase name.
    // Each test finds the TestCase by name at runtime and only runs if a query type is present.
    for name in &test_case_names {
        let fn_name = sanitize_ident(&format!("test_{}", name));
        let name_lit = escape_rust_string(name);

        writeln!(
            f,
            r#"
#[test]
fn {fn_name}() {{
    let _ = env_logger::builder().is_test(true).try_init();

    let driver = Driver::new_workspace().expect("Failed to create driver");

    let tc = ALL_TEST_CASES
        .iter()
        .find(|t| t.name == "{name_lit}")
        .expect("TestCase not found by name");

    // Only run for test cases with a query type (netlist with Some(..) or composite)
    let query_name_opt = match tc.pattern {{
        Pattern::Netlist {{ pattern_query_type: Some(name), .. }} => Some(name),
        Pattern::Composite {{ pattern_query_type: name }} => Some(name),
        _ => None,
    }};

    if let Some(name) = query_name_opt {{
        match run_count_by_type_name(name, &driver, tc) {{
            Ok(actual) => {{
                assert_eq!(
                    actual,
                    tc.expected_matches,
                    "Query test case '{{}}' failed: expected {{}} matches, got {{}}",
                    tc.name,
                    tc.expected_matches,
                    actual
                );
            }}
            Err(e) => panic!("Query test case '{{}}' failed: {{}}", tc.name, e),
        }}
    }} else {{
        // Not a query-backed test case; no-op to mirror other integration tests' filtering
    }}
}}
"#,
            fn_name = fn_name,
            name_lit = name_lit
        )
        .unwrap();
    }
}

fn discover_query_types(src_queries: &Path) -> Vec<Discovered> {
    let re_netlist = Regex::new(r#"netlist!\s*\{\s*name:\s*([A-Za-z_][A-Za-z0-9_]*)"#).unwrap();
    let re_composite = Regex::new(
        r#"impl\s+SearchableComposite\s+for\s+([A-Za-z_][A-Za-z0-9_]*)\s*<\s*Search\s*>"#,
    )
    .unwrap();
    let re_enum_composite = Regex::new(
        r#"impl\s+SearchableEnumComposite\s+for\s+([A-Za-z_][A-Za-z0-9_]*)\s*<\s*Search\s*>"#,
    )
    .unwrap();

    let mut found = Vec::new();

    for entry in WalkDir::new(src_queries).into_iter().filter_map(Result::ok) {
        let path = entry.path();
        if !path.is_file() || path.extension().and_then(|s| s.to_str()) != Some("rs") {
            continue;
        }
        let content = match fs::read_to_string(path) {
            Ok(s) => s,
            Err(_) => continue,
        };

        let module_path = path_to_module_path(src_queries, path);

        for cap in re_netlist.captures_iter(&content) {
            let type_name = cap[1].to_string();
            found.push(Discovered {
                kind: QueryKind::Netlist,
                type_name,
                module_path: module_path.clone(),
            });
        }

        for cap in re_composite.captures_iter(&content) {
            let type_name = cap[1].to_string();
            found.push(Discovered {
                kind: QueryKind::Composite,
                type_name,
                module_path: module_path.clone(),
            });
        }

        for cap in re_enum_composite.captures_iter(&content) {
            let type_name = cap[1].to_string();
            found.push(Discovered {
                kind: QueryKind::EnumComposite,
                type_name,
                module_path: module_path.clone(),
            });
        }
    }

    found
}

// Read svql_common/src/test_cases.rs and pull out all TestCase names.
// We keep it simple: find `TestCase { name: "<literal>",` occurrences.
fn extract_test_case_names(path: &Path) -> Vec<String> {
    let Ok(content) = fs::read_to_string(path) else {
        return Vec::new();
    };
    let re = Regex::new(r#"TestCase\s*\{\s*name:\s*"([^"]+)""#).unwrap();
    re.captures_iter(&content)
        .filter_map(|c| c.get(1).map(|m| m.as_str().to_string()))
        .collect()
}

// Convert src/queries/netlist/basic/and.rs -> svql_query::queries::netlist::basic::and
fn path_to_module_path(base: &Path, file: &Path) -> String {
    let mut comps: Vec<String> = Vec::new();
    comps.push("svql_query".to_string());
    comps.push("queries".to_string());

    let under_queries = file.strip_prefix(base).unwrap_or(file);
    for c in under_queries
        .parent()
        .into_iter()
        .flat_map(|p| p.components())
    {
        let s = c.as_os_str().to_string_lossy().to_string();
        comps.push(s);
    }

    if let Some(stem) = file.file_stem().and_then(|s| s.to_str()) {
        comps.push(stem.to_string());
    }
    comps.join("::")
}

// Make a string usable as a Rust identifier
fn sanitize_ident(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for (i, ch) in s.chars().enumerate() {
        let valid = ch.is_ascii_alphanumeric() || ch == '_';
        if (i == 0 && ch.is_ascii_digit()) || !valid {
            out.push('_');
        } else {
            out.push(ch);
        }
    }
    out
}

// Escape a Rust string literal safely
fn escape_rust_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}
