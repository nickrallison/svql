//! Core traits for query components and execution.
//!
//! Defines the interfaces that all netlists, composites, and variants must
//! implement to participate in the SVQL query system.

use std::any::TypeId;

pub mod component;
pub mod composite;
pub mod netlist;
pub mod variant;

// Re-export key traits
pub use component::{MatchedComponent, SearchableComponent, kind};
pub use composite::{
    CompositeComponent, CompositeMatched, ConnectionBuilder, Connections, Topology,
    validate_composite,
};
pub use netlist::{NetlistComponent, NetlistMatched, execute_netlist_query, report_netlist};
pub use variant::{VariantComponent, VariantMatched};

use crate::prelude::*;
use crate::session::{ColumnDef, ExecutionContext, PatternRegistry, QueryError, Row, Store, Table};

/// The central hardware abstraction for query components.
pub trait Hardware: std::fmt::Debug {
    /// The current state (Search or Match).
    type State: State;

    /// Returns the hierarchical path of the component.
    fn path(&self) -> &Instance;

    /// Returns the static type name of the component.
    fn type_name(&self) -> &'static str;

    /// Returns a list of immediate child wires or submodules.
    fn children(&self) -> Vec<&dyn Hardware<State = Self::State>>;

    /// Performs a recursive lookup for a port wire by its hierarchical path.
    fn find_port(&self, path: &Instance) -> Option<&Wire<Self::State>> {
        if path == self.path() {
            return None;
        }
        for child in self.children() {
            if path.starts_with(child.path())
                && let Some(port) = child.find_port(path)
            {
                return Some(port);
            }
        }
        None
    }

    /// Retrieves the source location by aggregating child source information.
    fn source(&self) -> Option<SourceLocation> {
        self.children().iter().find_map(|c| c.source())
    }

    /// Generates a report node for the component and its children.
    fn report(&self, name: &str) -> ReportNode {
        let children_reports = self
            .children()
            .iter()
            .map(|c| c.report(c.path().name()))
            .collect();

        ReportNode {
            name: name.to_string(),
            type_name: self.type_name().to_string(),
            path: self.path().clone(),
            source_loc: self.source(),
            children: children_reports,
            details: None,
        }
    }
}

/// Defines a pattern that can be instantiated and searched within a design.
///
/// **Note:** This trait has a blanket implementation for all types implementing
/// `SearchableComponent`. Manual implementation is only required for custom patterns.
///
/// # New DataFrame API
///
/// The following methods are part of the new DataFrame-based execution model:
/// - [`columns()`](Pattern::columns) - Schema for DataFrame storage
/// - [`dependencies()`](Pattern::dependencies) - TypeIds of required submodules
/// - [`register_all()`](Pattern::register_all) - Register pattern and deps in registry
/// - [`search()`](Pattern::search) - Execute search returning a Table
/// - [`rehydrate()`](Pattern::rehydrate) - Convert a Row back to Match type-state
pub trait Pattern: Hardware<State = Search> + Sized + Clone {
    /// The corresponding result type in the Match state.
    type Match: Matched<Search = Self>;

    /// Instantiates the pattern at the specified hierarchical path.
    fn instantiate(base_path: Instance) -> Self;

    /// Prepares the design context required for this pattern.
    ///
    /// **Legacy API** - Will be deprecated. Use `search()` instead.
    fn context(
        driver: &Driver,
        config: &ModuleConfig,
    ) -> Result<Context, Box<dyn std::error::Error>>;

    /// Executes the pattern search against a design context.
    ///
    /// **Legacy API** - Will be deprecated. Use `search()` instead.
    fn execute(
        &self,
        driver: &Driver,
        context: &Context,
        key: &DriverKey,
        config: &Config,
    ) -> Vec<Self::Match>;

    // =========================================================================
    // New DataFrame API (Phase 4)
    // =========================================================================

    /// Column schema for DataFrame storage.
    ///
    /// Defines the columns that will be present in `Table<Self>`.
    /// Generated by macros from `#[wire]` and `#[submodule]` fields.
    ///
    /// # Default Implementation
    ///
    /// Returns an empty slice. Override in macro-generated code.
    fn columns() -> &'static [ColumnDef] {
        &[]
    }

    /// Dependencies as TypeIds.
    ///
    /// Returns the TypeIds of all submodule patterns that must be searched
    /// before this pattern. Generated from `#[submodule]` fields.
    ///
    /// # Default Implementation
    ///
    /// Returns an empty slice. Override in macro-generated code.
    fn dependencies() -> &'static [TypeId] {
        &[]
    }

    /// Register this pattern and all dependencies into the registry.
    ///
    /// Called during `ExecutionPlan::for_pattern::<P>()` to build the DAG.
    /// Implementations should:
    /// 1. Call `register_all()` on each dependency
    /// 2. Call `registry.register()` for self
    ///
    /// # Default Implementation
    ///
    /// Registers self with no dependencies. Override in macro-generated code.
    fn register_all(registry: &mut PatternRegistry)
    where
        Self: 'static,
    {
        registry.register(
            TypeId::of::<Self>(),
            std::any::type_name::<Self>(),
            Self::dependencies(),
        );
    }

    /// Execute the search and return results as a Table.
    ///
    /// This is the new DataFrame-based search API. The `ExecutionContext`
    /// provides access to:
    /// - `ctx.driver()` - For design/needle operations
    /// - `ctx.driver_key()` - The design being searched
    /// - `ctx.get::<Dep>()` - Tables of completed dependencies
    ///
    /// # Default Implementation
    ///
    /// Returns an empty table. Override in macro-generated code.
    fn search(_ctx: &ExecutionContext<'_>) -> Result<Table<Self>, QueryError>
    where
        Self: Send + Sync + 'static,
    {
        Table::empty(Self::columns())
    }

    /// Rehydrate a Row back to the Match type-state.
    ///
    /// Reconstructs a full `Self::Match` object from the row data and
    /// any referenced submodule rows in the store.
    ///
    /// # Default Implementation
    ///
    /// Returns `None`. Override in macro-generated code.
    fn rehydrate(_row: &Row<Self>, _store: &Store) -> Option<Self::Match>
    where
        Self: 'static,
    {
        None
    }
}

/// Represents a query result bound to specific design elements.
///
/// **Note:** This trait has a blanket implementation for all types implementing
/// `MatchedComponent`. Manual implementation is only required for custom patterns.
pub trait Matched: Hardware<State = Match> + Sized + Clone {
    /// The corresponding pattern type in the Search state.
    type Search: Pattern<Match = Self>;
}

/// Validates that a physical connection exists between two matched wires in the haystack.
pub fn validate_connection<'ctx>(
    from: &Wire<Match>,
    to: &Wire<Match>,
    haystack_index: &GraphIndex<'ctx>,
) -> bool {
    validate_connection_inner(from, to, haystack_index).unwrap_or(false)
}

/// Internal helper to resolve CellInfo to CellWrappers and check connectivity.
fn validate_connection_inner<'ctx>(
    from: &Wire<Match>,
    to: &Wire<Match>,
    haystack_index: &GraphIndex<'ctx>,
) -> Option<bool> {
    let from_id = from.inner.as_ref()?.id;
    let to_id = to.inner.as_ref()?.id;

    let f_wrapper = haystack_index.get_cell_by_id(from_id)?;
    let t_wrapper = haystack_index.get_cell_by_id(to_id)?;

    let fanout = haystack_index.fanout_set(f_wrapper)?;
    Some(fanout.contains(t_wrapper))
}
