//! Storage for dehydrated query results in DataFrame format.
//!
//! Results are stored as DataFrames with foreign key references to:
//! - Cell IDs in the design
//! - Match indices in other query result tables
//! - Self-references for recursive types (parent_idx for linked structures)

use std::any::TypeId;
use std::collections::HashMap;

use polars::prelude::*;

use super::SessionError;
use super::foreign_key::ForeignKey;
use crate::traits::Pattern;

/// Descriptor for a wire field in a query type.
#[derive(Debug, Clone)]
pub struct WireFieldDesc {
    /// Field name (e.g., "clk", "d", "q")
    pub name: &'static str,
}

/// Descriptor for a submodule field in a query type.
#[derive(Debug, Clone)]
pub struct SubmoduleFieldDesc {
    /// Field name (e.g., "gate_a", "dff")
    pub name: &'static str,
    /// Type name of the submodule (for lookup)
    pub type_name: &'static str,
}

/// Descriptor for a recursive child field (self-referential).
#[derive(Debug, Clone)]
pub struct RecursiveFieldDesc {
    /// Field name (e.g., "child")
    pub name: &'static str,
}

/// Schema descriptor for a query type's dehydrated form.
/// Generated by macros to describe the structure.
#[derive(Debug, Clone)]
pub struct QuerySchema {
    /// The query type name
    pub type_name: &'static str,
    /// Wire fields
    pub wires: &'static [WireFieldDesc],
    /// Submodule fields
    pub submodules: &'static [SubmoduleFieldDesc],
    /// Recursive child field (for self-referential types like RecOr)
    pub recursive_child: Option<&'static RecursiveFieldDesc>,
}

impl QuerySchema {
    /// Creates a new schema descriptor.
    pub const fn new(
        type_name: &'static str,
        wires: &'static [WireFieldDesc],
        submodules: &'static [SubmoduleFieldDesc],
    ) -> Self {
        Self {
            type_name,
            wires,
            submodules,
            recursive_child: None,
        }
    }

    /// Creates a new schema descriptor with a recursive child field.
    pub const fn with_recursive_child(
        type_name: &'static str,
        wires: &'static [WireFieldDesc],
        submodules: &'static [SubmoduleFieldDesc],
        recursive_child: &'static RecursiveFieldDesc,
    ) -> Self {
        Self {
            type_name,
            wires,
            submodules,
            recursive_child: Some(recursive_child),
        }
    }
}

/// A dehydrated row that can be collected into a DataFrame.
/// This is the intermediate format between Match objects and DataFrames.
#[derive(Debug, Clone)]
pub struct DehydratedRow {
    /// The hierarchical path
    pub path: String,
    /// Wire cell IDs: field_name -> cell_id (None if unbound)
    pub wires: HashMap<&'static str, Option<u32>>,
    /// Submodule match indices: field_name -> match_idx
    pub submodules: HashMap<&'static str, u32>,
    /// Recursive child index (for self-referential types)
    /// None means no child (leaf node), Some(idx) points to another row in the same table
    pub child_idx: Option<u32>,
    /// Depth in the recursive structure (1 for leaf, higher for nested)
    pub depth: u32,
}

impl DehydratedRow {
    /// Creates a new dehydrated row.
    pub fn new(path: impl Into<String>) -> Self {
        Self {
            path: path.into(),
            wires: HashMap::new(),
            submodules: HashMap::new(),
            child_idx: None,
            depth: 1,
        }
    }

    /// Sets a wire cell ID.
    pub fn with_wire(mut self, name: &'static str, cell_id: Option<u32>) -> Self {
        self.wires.insert(name, cell_id);
        self
    }

    /// Sets a submodule match index.
    pub fn with_submodule(mut self, name: &'static str, match_idx: u32) -> Self {
        self.submodules.insert(name, match_idx);
        self
    }

    /// Sets a submodule reference using a typed foreign key.
    ///
    /// This is the preferred method when you have a `ForeignKey<T>`.
    pub fn with_submodule_fk<T>(mut self, name: &'static str, fk: ForeignKey<T>) -> Self {
        self.submodules.insert(name, fk.raw());
        self
    }

    /// Sets the recursive child index.
    pub fn with_child(mut self, child_idx: Option<u32>) -> Self {
        self.child_idx = child_idx;
        self
    }

    /// Sets the depth in the recursive structure.
    pub fn with_depth(mut self, depth: u32) -> Self {
        self.depth = depth;
        self
    }

    /// Gets a wire cell ID.
    pub fn wire(&self, name: &str) -> Option<u32> {
        self.wires.get(name).copied().flatten()
    }

    /// Gets a submodule match index.
    pub fn submodule(&self, name: &str) -> Option<u32> {
        self.submodules.get(name).copied()
    }

    /// Gets the child index for recursive types.
    pub fn child(&self) -> Option<u32> {
        self.child_idx
    }
}

/// A single row of match data retrieved from a DataFrame.
#[derive(Debug, Clone)]
pub struct MatchRow {
    /// Index of this match within its query type's results.
    pub match_idx: u32,
    /// The hierarchical path of the match.
    pub path: String,
    /// Wire cell IDs (field name -> cell_id or None).
    pub wire_cells: HashMap<String, Option<u32>>,
    /// Submodule match indices (field name -> index into that submodule's results).
    pub submodule_refs: HashMap<String, u32>,
    /// Child index for recursive types (self-reference).
    pub child_idx: Option<u32>,
    /// Depth in recursive structure (1 for leaf).
    pub depth: u32,
}

impl MatchRow {
    /// Gets a wire cell ID by field name.
    pub fn wire(&self, name: &str) -> Option<u32> {
        self.wire_cells.get(name).copied().flatten()
    }

    /// Gets a submodule match index by field name.
    pub fn submodule(&self, name: &str) -> Option<u32> {
        self.submodule_refs.get(name).copied()
    }

    /// Gets a typed foreign key for a submodule field.
    ///
    /// This provides compile-time type safety for resolving the reference.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let rec_or_fk = row.foreign_key::<RecOr<Match>>("rec_or")?;
    /// let rec_or_row = rec_or_fk.resolve(&store)?;
    /// ```
    pub fn foreign_key<T>(&self, name: &str) -> Option<ForeignKey<T>> {
        self.submodule(name).map(ForeignKey::new)
    }

    /// Gets the child index for recursive types.
    pub fn child(&self) -> Option<u32> {
        self.child_idx
    }

    /// Gets a typed foreign key for the recursive child.
    ///
    /// For self-referential types like `RecOr`, this returns a foreign key
    /// pointing to another row in the same table.
    pub fn child_key<T>(&self) -> Option<ForeignKey<T>> {
        self.child_idx.map(ForeignKey::new)
    }
}

/// Results for a single query type.
#[derive(Debug, Clone)]
pub struct QueryResults {
    /// The type name for display/debugging.
    pub type_name: String,
    /// Main results DataFrame with schema dependent on query type.
    /// Common columns: [match_idx (u32), path (str)]
    /// Wire columns: [wire_<name>_cell_id (u32, nullable)]
    /// Submodule columns: [sub_<name>_idx (u32)] - foreign key to other QueryResults
    pub matches: DataFrame,
    /// Wire column names (full column names like "wire_clk_cell_id")
    wire_columns: Vec<String>,
    /// Submodule references: field_name -> referenced type name
    submodule_columns: HashMap<String, String>,
}

impl QueryResults {
    /// Creates empty results for a query type.
    pub fn empty(type_name: impl Into<String>) -> Self {
        Self {
            type_name: type_name.into(),
            matches: DataFrame::empty(),
            wire_columns: Vec::new(),
            submodule_columns: HashMap::new(),
        }
    }

    /// Creates QueryResults from a schema and dehydrated rows.
    pub fn from_rows(schema: &QuerySchema, rows: Vec<DehydratedRow>) -> Result<Self, SessionError> {
        let n = rows.len();

        // Build columns
        let match_indices: Vec<u32> = (0..n as u32).collect();
        let paths: Vec<String> = rows.iter().map(|r| r.path.clone()).collect();

        let mut columns: Vec<Column> = vec![
            Column::new("match_idx".into(), &match_indices),
            Column::new("path".into(), &paths),
        ];

        // Wire columns
        let mut wire_col_names = Vec::new();
        for wire in schema.wires {
            let col_name = format!("wire_{}_cell_id", wire.name);
            let values: Vec<Option<u32>> = rows
                .iter()
                .map(|r| r.wires.get(wire.name).copied().flatten())
                .collect();
            columns.push(Column::new(col_name.clone().into(), &values));
            wire_col_names.push(col_name);
        }

        // Submodule columns
        let mut submodule_col_map = HashMap::new();
        for sub in schema.submodules {
            let col_name = format!("sub_{}_idx", sub.name);
            let values: Vec<u32> = rows
                .iter()
                .map(|r| r.submodules.get(sub.name).copied().unwrap_or(u32::MAX))
                .collect();
            columns.push(Column::new(col_name.into(), &values));
            submodule_col_map.insert(sub.name.to_string(), sub.type_name.to_string());
        }

        let matches = DataFrame::new(columns)?;

        Ok(Self {
            type_name: schema.type_name.to_string(),
            matches,
            wire_columns: wire_col_names,
            submodule_columns: submodule_col_map,
        })
    }

    /// Returns the number of matches.
    pub fn len(&self) -> usize {
        self.matches.height()
    }

    /// Returns true if there are no matches.
    pub fn is_empty(&self) -> bool {
        self.matches.is_empty()
    }

    /// Returns the matches DataFrame.
    pub fn df(&self) -> &DataFrame {
        &self.matches
    }

    /// Gets a match row by index.
    pub fn get(&self, match_idx: u32) -> Option<MatchRow> {
        let idx = match_idx as usize;
        if idx >= self.matches.height() {
            return None;
        }

        let path = self
            .matches
            .column("path")
            .ok()?
            .str()
            .ok()?
            .get(idx)?
            .to_string();

        let mut wire_cells = HashMap::new();
        for col_name in &self.wire_columns {
            let cell_id = self.matches.column(col_name).ok()?.u32().ok()?.get(idx);
            let field_name = col_name
                .strip_prefix("wire_")
                .and_then(|s| s.strip_suffix("_cell_id"))
                .unwrap_or(col_name)
                .to_string();
            wire_cells.insert(field_name, cell_id);
        }

        let mut submodule_refs = HashMap::new();
        for (field_name, _type_name) in &self.submodule_columns {
            let col_name = format!("sub_{}_idx", field_name);
            if let Ok(col) = self.matches.column(&col_name) {
                if let Ok(u32_col) = col.u32() {
                    if let Some(sub_idx) = u32_col.get(idx) {
                        if sub_idx != u32::MAX {
                            submodule_refs.insert(field_name.clone(), sub_idx);
                        }
                    }
                }
            }
        }

        // Extract child_idx and depth columns if they exist
        let child_idx = self
            .matches
            .column("child_idx")
            .ok()
            .and_then(|c| c.u32().ok())
            .and_then(|c| c.get(idx));

        let depth = self
            .matches
            .column("depth")
            .ok()
            .and_then(|c| c.u32().ok())
            .and_then(|c| c.get(idx))
            .unwrap_or(1);

        Some(MatchRow {
            match_idx,
            path,
            wire_cells,
            submodule_refs,
            child_idx,
            depth,
        })
    }

    /// Returns an iterator over all match indices.
    pub fn iter_indices(&self) -> impl Iterator<Item = u32> {
        0..self.len() as u32
    }

    /// Returns an iterator over all match rows.
    pub fn iter_rows(&self) -> impl Iterator<Item = MatchRow> + '_ {
        (0..self.len() as u32).filter_map(|i| self.get(i))
    }
}

/// Central storage for all query results.
#[derive(Debug, Default)]
pub struct ResultStore {
    /// Results keyed by TypeId.
    results: HashMap<TypeId, QueryResults>,
    /// Type name to TypeId mapping for lookup by name.
    name_to_type: HashMap<String, TypeId>,
}

impl ResultStore {
    /// Creates an empty result store.
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns the number of stored query types.
    pub fn len(&self) -> usize {
        self.results.len()
    }

    /// Returns true if no results are stored.
    pub fn is_empty(&self) -> bool {
        self.results.is_empty()
    }

    /// Inserts results for a query type.
    pub fn insert<P: Pattern + 'static>(&mut self, results: QueryResults) {
        let type_id = TypeId::of::<P>();
        let type_name = results.type_name.clone();
        self.name_to_type.insert(type_name, type_id);
        self.results.insert(type_id, results);
    }

    /// Inserts results with raw TypeId (for builder pattern).
    pub(crate) fn insert_raw(&mut self, type_id: TypeId, type_name: String, results: QueryResults) {
        self.name_to_type.insert(type_name, type_id);
        self.results.insert(type_id, results);
    }

    /// Gets results for a query type.
    pub fn get<P: Pattern + 'static>(&self) -> Option<&QueryResults> {
        self.results.get(&TypeId::of::<P>())
    }

    /// Gets results by type name.
    pub fn get_by_name(&self, type_name: &str) -> Option<&QueryResults> {
        let type_id = self.name_to_type.get(type_name)?;
        self.results.get(type_id)
    }

    /// Returns an iterator over all stored results.
    pub fn iter(&self) -> impl Iterator<Item = (&TypeId, &QueryResults)> {
        self.results.iter()
    }

    /// Returns all type names with stored results.
    pub fn type_names(&self) -> impl Iterator<Item = &str> {
        self.name_to_type.keys().map(|s| s.as_str())
    }

    /// Gets a specific row by type name and index.
    ///
    /// This is used by `ForeignKey::resolve()` for type-safe lookups.
    pub fn get_row(&self, type_name: &str, index: u32) -> Option<MatchRow> {
        let results = self.get_by_name(type_name)?;
        results.get(index)
    }
}

/// Trait for query Match types that can be dehydrated into DataFrame rows.
/// This is implemented by macros for each query type.
pub trait Dehydrate: Sized {
    /// The schema describing this type's structure.
    const SCHEMA: QuerySchema;

    /// Converts this match to a dehydrated row.
    fn dehydrate(&self) -> DehydratedRow;

    /// Dehydrates a collection of matches into QueryResults.
    fn dehydrate_all(matches: &[Self]) -> Result<QueryResults, SessionError> {
        let rows: Vec<DehydratedRow> = matches.iter().map(|m| m.dehydrate()).collect();
        QueryResults::from_rows(&Self::SCHEMA, rows)
    }
}

/// Accumulated dehydrated results during a search.
///
/// This is used by `SearchDehydrate` to collect results for the primary type
/// and all submodule types during a single search pass.
#[derive(Debug, Default)]
pub struct DehydratedResults {
    /// Results keyed by type name
    pub tables: std::collections::HashMap<&'static str, Vec<DehydratedRow>>,
    /// Schemas keyed by type name (first one registered wins)
    schemas: std::collections::HashMap<&'static str, &'static QuerySchema>,
}

impl DehydratedResults {
    /// Creates a new empty results collection.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a row to the specified type's table, returning its index.
    pub fn push(&mut self, type_name: &'static str, row: DehydratedRow) -> u32 {
        let table = self.tables.entry(type_name).or_default();
        let idx = table.len() as u32;
        table.push(row);
        idx
    }

    /// Registers a schema for a type. First registration wins.
    pub fn register_schema(&mut self, type_name: &'static str, schema: &'static QuerySchema) {
        self.schemas.entry(type_name).or_insert(schema);
    }

    /// Adds a row with schema registration, returning its index.
    pub fn push_with_schema(
        &mut self,
        type_name: &'static str,
        schema: &'static QuerySchema,
        row: DehydratedRow,
    ) -> u32 {
        self.register_schema(type_name, schema);
        self.push(type_name, row)
    }

    /// Adds a row for a typed Match, returning a typed foreign key.
    ///
    /// This automatically registers the schema and uses the full type path
    /// (`std::any::type_name::<T>()`) as the storage key.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let rec_or_fk: ForeignKey<RecOr<Match>> = results.push_typed::<RecOr<Match>>(row);
    /// // Later: rec_or_fk.resolve(&store)
    /// ```
    pub fn push_typed<T: Dehydrate>(&mut self, row: DehydratedRow) -> ForeignKey<T> {
        let type_key = std::any::type_name::<T>();
        self.register_schema(type_key, &T::SCHEMA);
        let idx = self.push(type_key, row);
        ForeignKey::new(idx)
    }

    /// Gets the current count for a type (useful for generating indices).
    pub fn len(&self, type_name: &str) -> usize {
        self.tables.get(type_name).map(|t| t.len()).unwrap_or(0)
    }

    /// Merges another DehydratedResults into this one.
    /// Returns a mapping of old indices to new indices for each type.
    pub fn merge(
        &mut self,
        other: DehydratedResults,
    ) -> std::collections::HashMap<&'static str, Vec<u32>> {
        let mut index_maps = std::collections::HashMap::new();

        // Merge schemas (first one wins)
        for (type_name, schema) in other.schemas {
            self.schemas.entry(type_name).or_insert(schema);
        }

        for (type_name, rows) in other.tables {
            let table = self.tables.entry(type_name).or_default();
            let base_idx = table.len() as u32;
            let new_indices: Vec<u32> = (0..rows.len() as u32).map(|i| base_idx + i).collect();
            table.extend(rows);
            index_maps.insert(type_name, new_indices);
        }

        index_maps
    }

    /// Converts all accumulated results into QueryResults for storage.
    /// Uses the internally registered schemas.
    pub fn into_query_results(
        self,
    ) -> Result<std::collections::HashMap<String, QueryResults>, SessionError> {
        let mut results = std::collections::HashMap::new();

        for (type_name, rows) in self.tables {
            if let Some(schema) = self.schemas.get(type_name) {
                let qr = QueryResults::from_rows(schema, rows)?;
                results.insert(type_name.to_string(), qr);
            }
        }

        Ok(results)
    }
}
