// use std::{env, fs::File, io::Write, path::PathBuf};

// use proc_macro2::{Ident, Span};
// use quote::quote;
// use svql_common::build_support::{sanitize_ident, test_case_names};

// fn main() {
//     // Re-run whenever the list of test cases changes
//     println!("cargo:rerun-if-changed=../svql_common/src/test_cases.rs");

//     let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
//     let out_file = out_dir.join("svql_driver_generated_tests.rs");

//     let test_case_names = test_case_names();

//     // Build test fns
//     let test_fns = test_case_names.iter().map(|name| {
//         let fn_ident = Ident::new(
//             &sanitize_ident(&format!("test_driver_{}", name)),
//             Span::call_site(),
//         );
//         let name_lit = name.as_str();

//         quote! {
//             #[test]
//             fn #fn_ident() {
//                 // Initialize test logger (captured by the test harness)
//                 init_test_logger();

//                 // Find the TestCase by name
//                 let tc = ALL_TEST_CASES
//                     .iter()
//                     .find(|t| t.name == #name_lit)
//                     .expect("TestCase not found by name");

//                 // Only run for netlist-backed test cases
//                 if let Pattern::Netlist { path: needle_path, module: needle_module, .. } = tc.pattern {
//                     let driver = Driver::new_workspace().expect("Failed to create driver");

//                     // Load pattern and haystack using the Driver
//                     let (pattern_key, pattern_design) = driver
//                         .get_or_load_design(*needle_path, (*needle_module).to_string(), &tc.config)
//                         .unwrap_or_else(|e| panic!("Failed to load pattern {}: {}", needle_path, e));

//                     let (haystack_key, haystack_design) = driver
//                         .get_or_load_design(tc.haystack.path, tc.haystack.module.to_string(), &tc.config)
//                         .unwrap_or_else(|e| panic!("Failed to load haystack {}: {}", tc.haystack.path, e));

//                     // Create a context with both designs
//                     let context = svql_driver::Context::new()
//                         .with_design(pattern_key.clone(), pattern_design)
//                         .with_design(haystack_key.clone(), haystack_design);

//                     let pattern_design = context
//                         .get(&pattern_key)
//                         .expect("Pattern design not found in context");

//                     let haystack_design = context
//                         .get(&haystack_key)
//                         .expect("Haystack design not found in context");

//                     // Run subgraph search using the design instances
//                     let matches = svql_subgraph::find_subgraph_isomorphisms(
//                         pattern_design.as_ref(),
//                         haystack_design.as_ref(),
//                         &tc.config,
//                     );

//                     assert_eq!(
//                         matches.len(),
//                         tc.expected_matches,
//                         "Driver test case '{}' failed: expected {} matches, got {}",
//                         tc.name,
//                         tc.expected_matches,
//                         matches.len()
//                     );
//                 } else {
//                     // Not applicable for subgraph engine; no-op to mirror selective test behavior
//                 }
//             }
//         }
//     });

//     let file_tokens = quote! {
//         // Auto-generated by build.rs. Do not edit by hand.

//         use svql_common::{ALL_TEST_CASES, Pattern};
//         use svql_driver::Driver;
//         use tracing_subscriber;

//         fn init_test_logger() {
//             let _ = tracing_subscriber::fmt()
//                 .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
//                 .with_test_writer()
//                 .try_init();
//         }

//         #(#test_fns)*
//     };

//     let mut f = File::create(&out_file).expect("Failed to create generated tests file");
//     f.write_all(file_tokens.to_string().as_bytes())
//         .expect("write generated tests");
// }

fn main() {
    // This is a placeholder for the main function
}
