// svql_driver/build.rs
// Generates a test per TestCase that exercises the Driver loading path and
// runs the subgraph matcher against each netlist-backed TestCase.

use std::{
    env,
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

use regex::Regex;

fn main() {
    // Re-run whenever the list of test cases changes
    println!("cargo:rerun-if-changed=../svql_common/src/test_cases.rs");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let common_dir = manifest_dir.join("..").join("svql_common");
    let test_cases_rs = common_dir.join("src").join("test_cases.rs");

    let test_case_names = extract_test_case_names(&test_cases_rs);

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let out_file = out_dir.join("svql_driver_generated_tests.rs");
    let mut f = File::create(&out_file).expect("Failed to create generated tests file");

    // Header
    writeln!(
        f,
        r#"
// Auto-generated by build.rs. Do not edit by hand.

use svql_common::{{ALL_TEST_CASES, Pattern}};
use svql_driver::Driver;
"#
    )
    .unwrap();

    // Generate a #[test] per TestCase name
    for name in &test_case_names {
        let fn_name = sanitize_ident(&format!("test_driver_{}", name));
        let name_lit = escape_rust_string(name);

        writeln!(
            f,
            r#"
#[test]
fn {fn_name}() {{
    // Initialize test logger (captured by the test harness)
    let _ = env_logger::builder().is_test(true).try_init();

    // Find the TestCase by name
    let tc = ALL_TEST_CASES
        .iter()
        .find(|t| t.name == "{name_lit}")
        .expect("TestCase not found by name");

    // Only run for netlist-backed test cases
    if let Pattern::Netlist {{ path: needle_path, module: needle_module, .. }} = tc.pattern {{
        let driver = Driver::new_workspace().expect("Failed to create driver");

        // Load pattern and haystack using the Driver
        let (pattern_key, pattern_design) = driver
            .get_or_load_design(*needle_path, (*needle_module).to_string())
            .unwrap_or_else(|e| panic!("Failed to load pattern {{}}: {{}}", needle_path, e));

        let (haystack_key, haystack_design) = driver
            .get_or_load_design(tc.haystack.path, tc.haystack.module.to_string())
            .unwrap_or_else(|e| panic!("Failed to load haystack {{}}: {{}}", tc.haystack.path, e));

        // Create a context with both designs
        let context = driver
            .create_context(&[pattern_key.clone(), haystack_key.clone()])
            .expect("Failed to create driver context");

        // Run subgraph search using the design instances
        let matches = svql_subgraph::find_subgraphs(
            pattern_design.as_ref(),
            haystack_design.as_ref(),
            &tc.config,
        );

        assert_eq!(
            matches.len(),
            tc.expected_matches,
            "Driver test case '{{}}' failed: expected {{}} matches, got {{}}",
            tc.name,
            tc.expected_matches,
            matches.len()
        );
    }} else {{
        // Not applicable for subgraph engine; no-op to mirror selective test behavior
    }}
}}
"#,
            fn_name = fn_name,
            name_lit = name_lit
        )
        .unwrap();
    }
}

fn extract_test_case_names(path: &Path) -> Vec<String> {
    let Ok(content) = fs::read_to_string(path) else {
        return Vec::new();
    };
    // Match: TestCase { name: "..." , ... }
    let re = Regex::new(r#"TestCase\s*\{\s*name:\s*"([^"]+)""#).unwrap();
    re.captures_iter(&content)
        .filter_map(|c| c.get(1).map(|m| m.as_str().to_string()))
        .collect()
}

fn sanitize_ident(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for (i, ch) in s.chars().enumerate() {
        let valid = ch.is_ascii_alphanumeric() || ch == '_';
        if (i == 0 && ch.is_ascii_digit()) || !valid {
            out.push('_');
        } else {
            out.push(ch);
        }
    }
    out
}

fn escape_rust_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}
